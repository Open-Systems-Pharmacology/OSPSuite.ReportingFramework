
#' creates a time profile for plotData, data are grouped ny "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a defualt list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotTimeProfile(convertUnits(
#'      myDataCombined,
#'      xUnit = ospUnits$Time$s,
#'      yUnit = ospUnits$`Concentration [mass]`$`Âµg/l`
#'  ))
#'  }
ospsuite_plotTimeProfile <- function(plotData,
                                     metaData = NULL,
                                     ...){
  if ("DataCombined" %in% class(plotData)) {
    plotData <- plotData$toDataFrame() %>%
      data.table::setDT()
  }
  checkmate::assertDataFrame(plotData)
  checkmate::assertNames(names(plotData),must.include = c('xValues','yValues','group'))


  # Capture additional arguments
  additional_args <- list(...)

  mapping <- additional_args$mapping
  additional_args$mapping <- NULL
  observedMapping <- additional_args$mapping
  additional_args$observedMapping <- NULL

  # create a copy, so changes to columns will stay inside function
  plotData = data.table::copy(data.table::setDT(plotData))

  if(is.null(metaData))
    metaData <- .constructMetDataForTimeProfile(plotData)

  if (any(names(metaData) %in% 'y2')){

    if (!('yDimension' %in% names(plotData))){
      plotData[,yDimension := ""]
      for (yUnitLoop in unique(plotData$yUnit)){
        plotData[yUnitLoop == yUnit,yDimension := getDimensionForUnit(yUnitLoop)]
      }
    }
  }

  # create plot Object
  plotObject <- do.call(what = ospsuite.plots::plotTimeProfile,
                        args = c(list(data = plotData[dataType == 'simulated'],
                                      mapping = .getMappingForTimeprofiles(
                                        plotData = plotData[dataType == 'simulated'],
                                        metaData = metaData,
                                        userMapping = mapping
                                      ),
                                      observedMapping = .getMappingForTimeprofiles(
                                        plotData = plotData[dataType == 'observed'],
                                        metaData = metaData,
                                        userMapping = observedMapping %||% mapping
                                      ),
                                      metaData =  metaData,
                                      observedData = plotData[dataType == 'observed']),
                                 additional_args)
  )

  return(plotObject)
}


#' construct metaData out of Data
#'
#' @param plotData
#'
#' @return list with metaData
.constructMetDataForTimeProfile <- function(plotData){

  xUnit <- unique(plotData$xUnit)
  if (length(xUnit) > 1) stop('x Unit ambiguous')
  if ('xDimension' %in% names(plotData)) {
    xDimension <- unique(plotData$xDimension)
  } else {
      xDimension <- ospsuite::getDimensionForUnit(xUnit)
  }
  yUnit <- unique(plotData$yUnit)
  if (length(yUnit) > 2) stop('y Unit ambiguous')
  if ('yDimension' %in% names(plotData)) {
    yDimension <- unique(plotData$yDimension)
  } else {
    yDimension <- unlist(lapply(yUnit, function(yUnit){ospsuite::getDimensionForUnit(yUnit)}))
  }

  metaData <- list(
    xValues = list(
      dimension = xDimension,
      unit = xUnit
    ),
    yValues = list(
      dimension = yDimension[1],
      unit = yUnit[1]
    )
  )
  if (length(yUnit) == 2){
    metaData[['y2']] = list(
      dimension = yDimension[2],
      unit = yUnit[2]
    )
  }

  return(metaData)

}


#' creates mapping for plotData
#'
#' @param plotData to map
#' @param metaData list with metaData for plotData
#'
#' @return mapping
.getMappingForTimeprofiles <- function(plotData,metaData,userMapping){
  mapping <- aes(x = xValues, y = yValues, groupby = group)

  # delete columns not needed
  plotData <- plotData[, which(colSums(is.na(plotData)) != nrow(plotData)), with = FALSE]

  if ('yErrorType' %in% names(plotData) &&
      any(plotData[['yErrorType']] %in% unlist(ospsuite::DataErrorType))){
    checkmate::assertNames(names(plotData),must.include = c('yErrorValues'),
                           disjunct.from = c('yMin','yMax'),
                           .var.name = 'columns needed for yErrorValues')

    if (length(unique(plotData[!is.na(yErrorType)][['yErrorType']])) > 1)
      stop('Please do not mix different error Types in one plot')

    if (any(plotData[['yErrorType']] == ospsuite::DataErrorType$ArithmeticStdDev))
      mapping <- structure(c(mapping, aes(error = yErrorValues)), class = "uneval")

    if (any(plotData[['yErrorType']] == ospsuite::DataErrorType$GeometricStdDev))
      mapping <- structure(c(mapping, aes(error_relative = yErrorValues)), class = "uneval")

  } else if (any(c('yMin','yMax') %in% names(plotData))){
    checkmate::assertNames(names(plotData),must.include = c('yMin','yMax'))
    mapping <- structure(c(mapping, aes(ymin = yMin,ymax = yMax)), class = "uneval")

  }
  if (any(names(plotData) %in% 'lloq'))
      mapping <- structure(c(mapping, aes(lloq = lloq)), class = "uneval")

  if (any(names(metaData) %in% 'y2')){

    mapping <- structure(c(mapping,
                         eval(parse(
                           text = paste0(
                             "aes( y2axis = yUnit == '",
                             metaData[['y2']][['unit']],"')"
                           )))),
                         class = "uneval")
  }

  if (!is.null(userMapping))
    mapping <- structure(utils::modifyList(mapping, userMapping), class = "uneval")


  return(mapping)

}
