#' Creates a time profile plot for given data.
#'
#' This function generates a time profile plot using ggplot2, where the data is grouped by a column named "group".
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        It is essential that the units are consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotTimeProfile`.
#'
#' @return A `ggplot2` plot object representing the time profile.
#' @export
#'
#' @examples \dontrun{
#' # Generate a time profile plot for the provided data
#' plotTimeProfile(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotTimeProfile <- function(plotData, # nolint
                                     metaData = NULL,
                                     mapping = ggplot2::aes(),
                                     observedMapping = mapping,
                                     ...) {
  # initialize variables used for data.table to avoid messages during checks
  yDimension <- yUnit <- dataType <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = FALSE)
  checkmate::assertNames(names(plotData), must.include = c("xUnit"))


  # Capture additional arguments
  additionalArgs <- list(...)

  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
  }

  if (any(names(metaData) %in% "y2")) {
    if (!("yDimension" %in% names(plotData))) {
      plotData[, yDimension := ""]
      for (yUnitLoop in unique(plotData$yUnit)) {
        plotData[yUnitLoop == yUnit, yDimension := ospsuite::getDimensionForUnit(yUnitLoop)]
      }
    }
  }
  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotTimeProfile,
    args = c(
      list(
        data = plotData[dataType == "simulated"],
        mapping = .getMappingForTimeprofiles(
          plotData = plotData[dataType == "simulated"],
          metaData = metaData,
          userMapping = mapping
        ),
        observedMapping = .getMappingForTimeprofiles(
          plotData = plotData[dataType == "observed"],
          metaData = metaData,
          userMapping = observedMapping
        ),
        metaData = metaData,
        observedData = plotData[dataType == "observed"]
      ),
      additionalArgs
    )
  )

  return(plotObject)
}
#' Plots predicted vs observed data, grouped by "group".
#'
#' This function visualizes the relationship between predicted and observed values, allowing for easy identification of discrepancies.
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        Units should be consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotPredVsObs`.
#'
#' @return A `ggplot2` plot object representing predicted vs observed values.
#' @export
#'
#' @examples \dontrun{
#' # Generate a predicted vs observed plot for the provided data
#' plotPredictedVsObserved(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotPredictedVsObserved <- function(plotData, #nolint
                                             metaData = NULL,
                                             mapping = ggplot2::aes(),
                                             ...) {
  # initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  additionalArgs <- list(...)

  mapping <- structure(
    utils::modifyList(
      ggplot2::aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotPredVsObs,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      additionalArgs
    )
  )

  return(plotObject)
}
#' Plots residuals vs Time, grouped by "group".
#'
#' This function visualizes the residuals over time, providing insights into the accuracy of the model predictions.
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        Units should be consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotResVsCov`.
#'
#' @return A `ggplot2` plot object representing residuals vs time.
#' @export
#'
#' @examples \dontrun{
#' # Generate a residuals vs time plot for the provided data
#' plotResidualsVsTime(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsVsTime <- function(plotData, #nolint
                                         metaData = NULL,
                                         mapping = ggplot2::aes(),
                                         ...) {
  # initialize variables used for data.table to avoid messages during checks
  xValues <- predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  additionalArgs <- list(...)

  mapping <- structure(
    utils::modifyList(
      ggplot2::aes(
        x = xValues,
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotResVsCov,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      additionalArgs
    )
  )

  return(plotObject)
}

#' Plots residuals vs observed values, grouped by "group".
#'
#' This function visualizes the residuals against observed values, helping to assess model performance.
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        Units should be consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotResVsCov`.
#'
#' @return A `ggplot2` plot object representing residuals vs observed values.
#' @export
#'
#' @examples \dontrun{
#' # Generate a residuals vs observed plot for the provided data
#' plotResidualsVsObserved(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsVsObserved <- function(plotData, #nolint
                                             metaData = NULL,
                                             mapping = ggplot2::aes(),
                                             ...) {
  # initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  additionalArgs <- list(...)

  mapping <- structure(
    utils::modifyList(
      ggplot2::aes(
        x = yValues,
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotResVsCov,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      additionalArgs
    )
  )

  return(plotObject)
}

#' Plots residuals as a histogram, grouped by "group".
#'
#' This function generates a histogram of the residuals, providing a visual representation of their distribution.
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        Units should be consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotHistogram`.
#'
#' @return A `ggplot2` plot object representing the histogram of residuals.
#' @export
#'
#' @examples \dontrun{
#' # Generate a histogram of residuals for the provided data
#' plotResidualsAsHistogram(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsAsHistogram <- function(plotData, #nolint
                                              metaData = NULL,
                                              mapping = ggplot2::aes(),
                                              ...) {
  # initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  additionalArgs <- list(...)

  mapping <- structure(
    utils::modifyList(
      ggplot2::aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }
  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotHistogram,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      additionalArgs
    )
  )

  return(plotObject)
}


#' Plots a Quantile-Quantile plot, grouped by "group".
#'
#' This function visualizes the distribution of predicted vs observed values using a Q-Q plot.
#'
#' @param plotData An object of class DataCombined or a data.frame generated by a DataCombined object.
#'        Units should be consistent; if not, use `convertUnits(myDataCombined)` to standardize.
#' @param metaData A list containing metadata for the plot. If NULL, a default list is constructed from the data.
#' @param... Additional arguments passed to `ospsuite.plots::plotQQ`.
#'
#' @return A `ggplot2` plot object representing the Q-Q plot.
#' @export
#'
#' @examples \dontrun{
#' # Generate a Q-Q plot for the provided data
#' plotQuantileQuantilePlot(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotQuantileQuantilePlot <- function(plotData, #nolint
                                              metaData = NULL,
                                              mapping = ggplot2::aes(),
                                              ...) {
  # initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  additionalArgs <- list(...)

  mapping <- structure(
    utils::modifyList(
      ggplot2::aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotQQ,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      additionalArgs
    )
  )

  return(plotObject)
}


#' Interpolates observed data based on simulated data.
#'
#' This function performs linear extrapolation for increasing yValues and logarithmic interpolation for decreasing yValues
#' based on the specified grouping identifiers. It modifies the input dtObserved data.table by adding a new column
#' with the predicted values.
#'
#' @param dtObserved A data.table containing observed data with columns `xValues`, `yValues`, and grouping identifiers.
#' @param dtSimulated A data.table containing simulated data with columns `xValues` and `yValues`.
#' @param identifier A character vector of column names used for grouping in the extrapolation and interpolation process.
#'
#' @return A data.table with an additional column named 'predicted' containing the extrapolated and interpolated values.
#' @export
addPredictedValues <- function(dtObserved, dtSimulated, identifier) {
  # initialize variables used for data.table to avoid messages during checks
  xValues <- predicted <- yValues <- diffY <- y <- NULL

  checkmate::assertCharacter(identifier, any.missing = FALSE)
  checkmate::assertDataTable(dtObserved)
  checkmate::assertNames(names(dtObserved),
    must.include = c("xValues", identifier)
  )
  checkmate::assertDataTable(dtSimulated)
  checkmate::assertNames(names(dtSimulated),
    must.include = c("xValues", "yValues", identifier)
  )

  # make sure to exclude nas and sorting is correct
  dtSimulated <- data.table::copy(dtSimulated) %>%
    dplyr::select(dplyr::all_of(c("xValues", "yValues", identifier))) %>%
    data.table::setorderv(c("xValues", identifier))
  dtSimulated <- dtSimulated[!is.nan(xValues) & !is.nan(yValues)]

  dtObserved[, predicted := {
    # Filter the simulated data based on the current group
    filterConditions <- lapply(identifier, function(id) dtSimulated[[id]] == .BY[[id]])
    filteredX <- dtSimulated[Reduce(`&`, filterConditions)]$xValues
    filteredY <- dtSimulated[Reduce(`&`, filterConditions)]$yValues

    # Get the current xValues from dtObserved
    currentXValues <- xValues # This refers to the xValues column in dtObserved

    # Initialize an empty vector for predictions
    predicted <- rep(NA, length(currentXValues))

    # Check if there are enough filtered points
    if (length(filteredX) < 2) {
      warning("Not enough data points for ", paste(identifier, .BY, collapse = ", "))
    } else {
      # Create a data.table for easier manipulation
      dtSimulatedGroup <- data.table(x = filteredX, y = filteredY)

      # Calculate differences
      dtSimulatedGroup[, diffY := c(NA, diff(y))]
      dtSimulatedGroup$diffY[1] <- dtSimulatedGroup$diffY[2]
      dtSimulatedGroup[y <= 0, diffY := 0]
      dtSimulatedGroup[data.table::shift(y, -1) <= 0, diffY := 0]

      maxX <- max(dtSimulatedGroup$x)

      # Loop through each xValue in the current group
      for (i in seq_along(currentXValues)) {
        xVal <- currentXValues[i]

        # Find the closest x in the filtered data
        closestIdx <- which(filteredX >= xVal)[1]
        x <- dtSimulatedGroup$x
        y <- dtSimulatedGroup$y

        # Check if the slope is positive or negative
        if (length(closestIdx) < 1 | xVal > maxX) {
          predicted[i] <- NA # Handle values outside limits
        } else {
          if (dtSimulatedGroup$diffY[closestIdx] >= 0) {
            # Linear extrapolation for increasing slope
            predicted[i] <- stats::approx(
              x = x,
              y = y,
              xout = xVal,
              rule = 1
            )$y
          } else {
            predicted[i] <- exp(stats::approx(
              x = x[y>0],
              y = log(y[y>0]),
              xout = xVal,
              rule = 1
            )$y)
          }
        }
      }
    }

    predicted # Return the predictions to be assigned to the new column
  }, by = identifier]

  return(dtObserved) # Return the modified dtObserved
}


#' Validates observed data and converts it to appropriate format.
#'
#' This function checks the input data for required columns and formats it for plotting. If predicted values are needed,
#' it calculates them based on the observed and simulated data.
#'
#' @param plotData Either a data.table with columns 'xValues', 'yValues', 'group' or an object of class 'DataCombined'.
#' @param predictedIsNeeded If TRUE, only observed data are returned. If FALSE and the "predicted" column does not exist,
#'        predicted values are calculated.
#'
#' @return A `data.table` with data formatted for plotting.
#' @keywords internal
.validateAndConvertData <- function(plotData, predictedIsNeeded) {
  # initialize variables used for data.table to avoid messages during checks
  dataType <- NULL

  if ("DataCombined" %in% class(plotData)) {
    plotData <- plotData$toDataFrame() %>%
      data.table::setDT()
  }
  checkmate::assertDataFrame(plotData)
  checkmate::assertNames(names(plotData), must.include = c("xValues", "yValues", "group", "dataType"))

  # create a copy, so changes to columns will stay inside function
  plotData <- data.table::copy(data.table::setDT(plotData))

  if (predictedIsNeeded) {
    if (!("predicted" %in% names(plotData))) {
      plotData <- addPredictedValues(
        dtObserved = plotData[dataType == "observed"],
        dtSimulated = plotData[dataType == "simulated"],
        identifier = "group"
      )
    } else {
      plotData[dataType == "observed"]
    }
  }

  if (nrow(plotData) == 0) {
    stop("No data for this plot available")
  }

  return(plotData)
}

#' Construct Metadata for Time Profile
#'
#' This function generates metadata for time profile plots based on the provided plot data.
#' It extracts and validates the dimensions and units for both x and y values, ensuring
#' that there is no ambiguity in the units.
#'
#' @param plotData A data.table containing the following relevant columns:
#'   - `xUnit`: The unit of the x-axis values.
#'   - `xDimension`: (optional) The dimension of the x values, if already specified.
#'   - `yUnit`: The unit(s) of the y-axis values (can be one or two units).
#'   - `yDimension`: (optional) The dimension of the y values, if already specified.
#'
#' @details
#' The function checks for ambiguities in the x and y units and retrieves the corresponding
#' dimensions. If two y units are provided, it constructs separate metadata for each.
#' The resulting metadata is returned as a list, which includes dimensions and units for
#' both x and y values.
#'
#' @return A list containing metadata with the following structure:
#' - `xValues`: A list with `dimension` and `unit` for the x-axis.
#' - `yValues`: A list with `dimension` and `unit` for the primary y-axis.
#' - `y2`: (optional) A list with `dimension` and `unit` for the secondary y-axis if applicable.
#' @keywords internal
.constructMetDataForTimeProfile <- function(plotData) {
  xUnit <- unique(plotData$xUnit)
  if (length(xUnit) > 1) stop("x Unit ambiguous")
  if ("xDimension" %in% names(plotData)) {
    xDimension <- unique(plotData$xDimension)
  } else {
    xDimension <- ospsuite::getDimensionForUnit(xUnit)
  }
  yUnit <- unique(plotData$yUnit)
  if (length(yUnit) > 2) stop("y Unit ambiguous")
  if ("yDimension" %in% names(plotData)) {
    yDimension <- unique(plotData$yDimension)
  } else {
    yDimension <- unlist(lapply(yUnit, function(yUnit) {
      ospsuite::getDimensionForUnit(yUnit)
    }))
  }

  metaData <- list(
    xValues = list(
      dimension = xDimension,
      unit = xUnit
    ),
    yValues = list(
      dimension = yDimension[1],
      unit = yUnit[1]
    )
  )
  if (length(yUnit) == 2) {
    metaData[["y2"]] <- list(
      dimension = yDimension[2],
      unit = yUnit[2]
    )
  }

  return(metaData)
}


#' Creates mapping for plotData.
#'
#' This function generates a mapping for the plotting based on the provided plot data and metadata.
#'
#' @param plotData Data to map.
#' @param metaData A list with metadata for plotData.
#' @param userMapping Mapping provided by the user; this will update the internal mapping.
#'
#' @return A mapping object for ggplot2.
#' @keywords internal
.getMappingForTimeprofiles <- function(plotData, metaData, userMapping) {
  # initialize variables used for data.table to avoid warnings during checks
  xValues <- yValues <- group <- yErrorType <- yErrorValues <- yMin <- yMax <- lloq <- NULL

  mapping <- ggplot2::aes(x = xValues, y = yValues, groupby = group)

  # delete columns not needed
  plotData <- plotData[, which(colSums(is.na(plotData)) != nrow(plotData)), with = FALSE]

  if ("yErrorType" %in% names(plotData) &&
      any(plotData[["yErrorType"]] %in% unlist(ospsuite::DataErrorType))) { #nolint
    checkmate::assertNames(names(plotData),
                           must.include = c("yErrorValues"), #nolint
                           disjunct.from = c("yMin", "yMax"),
                           .var.name = "columns needed for yErrorValues"
    )

    if (length(unique(plotData[!is.na(yErrorType)][["yErrorType"]])) > 1) {
      stop("Please do not mix different error Types in one plot")
    }

    if (any(plotData[["yErrorType"]] == ospsuite::DataErrorType$ArithmeticStdDev)) {
      mapping <- structure(c(mapping, ggplot2::aes(error = yErrorValues)), class = "uneval")
    }

    if (any(plotData[["yErrorType"]] == ospsuite::DataErrorType$GeometricStdDev)) {
      mapping <- structure(c(mapping, ggplot2::aes(error_relative = yErrorValues)), class = "uneval")
    }
  } else if (any(c("yMin", "yMax") %in% names(plotData))) {
    checkmate::assertNames(names(plotData), must.include = c("yMin", "yMax"))
    mapping <- structure(c(mapping, ggplot2::aes(ymin = yMin, ymax = yMax)), class = "uneval")
  }
  if (any(names(plotData) %in% "lloq")) {
    mapping <- structure(c(mapping, ggplot2::aes(lloq = lloq)), class = "uneval")
  }

  if (any(names(metaData) %in% "y2")) {
    mapping <- structure(
      c(
        mapping,
        eval(parse(
          text = paste0(
            "aes( y2axis = yUnit == '",
            metaData[["y2"]][["unit"]], "')"
          )
        ))
      ),
      class = "uneval"
    )
  }

  if (!is.null(userMapping)) {
    mapping <- structure(utils::modifyList(mapping, userMapping), class = "uneval")
  }


  return(mapping)
}
