#' creates a time profile for plotData, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotTimeProfile(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotTimeProfile <- function(plotData, #nolint
                                     metaData = NULL,
                                     ...) {
  #initialize variables used for data.table to avoid messages during checks
  yDimension <- yUnit <- dataType <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = FALSE)
  checkmate::assertNames(names(plotData), must.include = c("xUnit"))


  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  observedMapping <- AdditionalArgs$mapping
  AdditionalArgs$observedMapping <- NULL


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
  }

  if (any(names(metaData) %in% "y2")) {
    if (!("yDimension" %in% names(plotData))) {
      plotData[, yDimension := ""]
      for (yUnitLoop in unique(plotData$yUnit)) {
        plotData[yUnitLoop == yUnit, yDimension := getDimensionForUnit(yUnitLoop)]
      }
    }
  }
  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotTimeProfile,
    args = c(
      list(
        data = plotData[dataType == "simulated"],
        mapping = .getMappingForTimeprofiles(
          plotData = plotData[dataType == "simulated"],
          metaData = metaData,
          userMapping = mapping
        ),
        observedMapping = .getMappingForTimeprofiles(
          plotData = plotData[dataType == "observed"],
          metaData = metaData,
          userMapping = observedMapping %||% mapping
        ),
        metaData = metaData,
        observedData = plotData[dataType == "observed"]
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}
#' plots predicted vs observed, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotPredictedVsObserved(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotPredictedVsObserved <- function(plotData,
                                             metaData = NULL,
                                             ...) {
  #initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  mapping <- structure(
    utils::modifyList(
      aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotPredVsObs,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}
#' plots residuals vs Time, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotResidualsVsTime(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsVsTime <- function(plotData,
                                         metaData = NULL,
                                         ...) {
  #initialize variables used for data.table to avoid messages during checks
  xValues <- predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  mapping <- structure(
    utils::modifyList(
      aes(
        x = xValues,
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotResVsCov,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}

#' plots residuals vs observed, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotResidualsVsTime(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsVsObserved <- function(plotData,
                                             metaData = NULL,
                                             ...) {
  #initialize variables used for data.table to avoid messages during checks
  xValues <- predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  mapping <- structure(
    utils::modifyList(
      aes(
        x = yValues,
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotResVsCov,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}

#' plots residuals as hsitogram, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotResidualsAsHistogram(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotResidualsAsHistogram <- function(plotData,
                                              metaData = NULL,
                                              ...) {
  #initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  mapping <- structure(
    utils::modifyList(
      aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }
  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotHistogram,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}


#' plots residuals as hsitogram, data are grouped by "group"
#'
#' @param plotData object of class dataCombined or dataFrame generated by dataCombined object
#'       units should be consistent, otherwise use convertUnits(myDataCombined)
#' @param metaData list with metaData, a default list is constructed from the data
#' @param ... arguments passed on to opssuite.plots::plotTimeProfile
#'
#' @return  `ggplot2`plotObject
#' @export
#'
#' @examples \dontrun{
#' plotResidualsAsHistogram(convertUnits(
#'   myDataCombined,
#'   xUnit = ospUnits$Time$h,
#'   yUnit = ospUnits$`Concentration [mass]`$`µg/l`
#' ))
#' }
ospsuite_plotQuantileQuantilePlot <- function(plotData,
                                              metaData = NULL,
                                              ...) {
  #initialize variables used for data.table to avoid messages during checks
  predicted <- yValues <- group <- NULL

  plotData <- .validateAndConvertData(plotData = plotData, predictedIsNeeded = TRUE)

  # Capture additional arguments
  AdditionalArgs <- list(...)

  mapping <- AdditionalArgs$mapping
  AdditionalArgs$mapping <- NULL
  mapping <- structure(
    utils::modifyList(
      aes(
        predicted = predicted,
        observed = yValues,
        groupby = group
      ),
      mapping
    ),
    class = "uneval"
  )


  if (is.null(metaData)) {
    metaData <- .constructMetDataForTimeProfile(plotData)
    metaData$predicted <- metaData$yValues
  }

  # create plot Object
  plotObject <- do.call(
    what = ospsuite.plots::plotQQ,
    args = c(
      list(
        data = plotData,
        mapping = mapping,
        metaData = metaData
      ),
      AdditionalArgs
    )
  )

  return(plotObject)
}


#' Interpolate
#'
#' This function performs linear extrapolation for increasing yValues and
#' logarithmic interpolation for decreasing yValues based on the specified
#' grouping identifiers. It modifies the input dtObserved data.table by
#' adding a new column with the predicted values.
#'
#' @param dtObserved A data.table containing observed data with xValues and
#'                   grouping identifiers.
#' @param dtSimulated A data.table containing simulated data with xValues
#'                    and corresponding yValues.
#' @param identifiers A character vector of column names used for grouping
#'                    in the extrapolation and interpolation process.
#'
#' @return A data.table with an additional column named 'predicted' containing
#'         the extrapolated and interpolated values.
#' @export
addPredictedValues <- function(dtObserved, dtSimulated, identifier) {
  #initialize variables used for data.table to avoid messages during checks
  xValues <- predicted <- yValues <- group <- diffY <- y <-NULL

  checkmate::assertCharacter(identifier, any.missing = FALSE)
  checkmate::assertDataTable(dtObserved)
  checkmate::assertNames(names(dtObserved),
    must.include = c("xValues", identifier)
  )
  checkmate::assertDataTable(dtSimulated)
  checkmate::assertNames(names(dtSimulated),
    must.include = c("xValues", "yValues", identifier)
  )

  # make sure to exclude nas and sorting is correct
  dtSimulated <- data.table::copy(dtSimulated) %>%
    dplyr::select(dplyr::all_of(c("xValues", "yValues", identifier))) %>%
    data.table::setorderv(dplyr::all_of(c("xValues", identifier)))
  dtSimulated <- dtSimulated[!is.nan(xValues) & !is.nan(yValues)]

  dtObserved[, predicted := {
    # Filter the simulated data based on the current group
    filterConditions <- lapply(identifier, function(id) dtSimulated[[id]] == .BY[[id]])
    filteredX <- dtSimulated[Reduce(`&`, filterConditions)]$xValues
    filteredY <- dtSimulated[Reduce(`&`, filterConditions)]$yValues

    # Get the current xValues from dtObserved
    currentXValues <- xValues # This refers to the xValues column in dtObserved

    # Initialize an empty vector for predictions
    predicted <- rep(NA, length(currentXValues))

    # Check if there are enough filtered points
    if (length(filteredX) < 2) {
      warning("Not enough data points for ", paste(identifier, .BY, collapse = ", "))
    } else {
      # Create a data.table for easier manipulation
      dtSimulatedGroup <- data.table(x = filteredX, y = filteredY)

      # Calculate differences
      dtSimulatedGroup[, diffY := c(NA, diff(y))]
      dtSimulatedGroup$diffY[1] <- dtSimulatedGroup$diffY[2]
      dtSimulatedGroup[y <= 0, diffY := 0]
      dtSimulatedGroup[data.table::shift(y, -1) <= 0, diffY := 0]

      maxX <- max(dtSimulatedGroup$x)

      # Loop through each xValue in the current group
      for (i in seq_along(currentXValues)) {
        xVal <- currentXValues[i]

        # Find the closest x in the filtered data
        closestIdx <- which(filteredX >= xVal)[1]

        # Check if the slope is positive or negative
        if (length(closestIdx) < 1 | xVal > maxX) {
          predicted[i] <- NA # Handle values outside limits
        } else {
          if (dtSimulatedGroup$diffY[closestIdx] >= 0) {
            # Linear extrapolation for increasing slope
            predicted[i] <- approx(
              x = dtSimulatedGroup$x,
              y = dtSimulatedGroup$y,
              xout = xVal,
              rule = 1
            )$y
          } else {
            predicted[i] <- exp(approx(
              x = dtSimulatedGroup$x,
              y = log(dtSimulatedGroup$y),
              xout = xVal,
              rule = 1
            )$y)
          }
        }
      }
    }

    predicted # Return the predictions to be assigned to the new column
  }, by = identifier]

  return(dtObserved) # Return the modified dtObserved
}


#' validates observed data and converts it to appropriate format
#'
#' @param plotData either data.table with columns 'xValues','yValues','group' or
#' object of class 'DataCombined'
#' @param predictedIsNeeded if TRUE only observed data are returned,
#'         if not column "predicted" exists, predicted values are caluclated
#'
#' @return `data.table` with data to plot
.validateAndConvertData <- function(plotData, predictedIsNeeded) {
  #initialize variables used for data.table to avoid messages during checks
  dataType <- xValues <- yValues <- group <-NULL

  if ("DataCombined" %in% class(plotData)) {
    plotData <- plotData$toDataFrame() %>%
      data.table::setDT()
  }
  checkmate::assertDataFrame(plotData)
  checkmate::assertNames(names(plotData), must.include = c("xValues", "yValues", "group","dataType"))

  # create a copy, so changes to columns will stay inside function
  plotData <- data.table::copy(data.table::setDT(plotData))

  if (predictedIsNeeded) {
    if (!("predicted" %in% names(plotData))) {
      plotData <- addPredictedValues(
        dtObserved = plotData[dataType == "observed"],
        dtSimulated = plotData[dataType == "simulated"],
        identifier = "group"
      )
    } else {
      plotData[dataType == "observed"]
    }
  }

  if (nrow(plotData) == 0) {
    stop("No data for this plot available")
  }

  return(plotData)
}

#' construct metaData out of Data
#'
#' @param plotData
#'
#' @return list with metaData
.constructMetDataForTimeProfile <- function(plotData) {
  #initialize variables used for data.table to avoid messages during checks
  dataType <- xValues <- yValues <- group <-NULL

  xUnit <- unique(plotData$xUnit)
  if (length(xUnit) > 1) stop("x Unit ambiguous")
  if ("xDimension" %in% names(plotData)) {
    xDimension <- unique(plotData$xDimension)
  } else {
    xDimension <- ospsuite::getDimensionForUnit(xUnit)
  }
  yUnit <- unique(plotData$yUnit)
  if (length(yUnit) > 2) stop("y Unit ambiguous")
  if ("yDimension" %in% names(plotData)) {
    yDimension <- unique(plotData$yDimension)
  } else {
    yDimension <- unlist(lapply(yUnit, function(yUnit) {
      ospsuite::getDimensionForUnit(yUnit)
    }))
  }

  metaData <- list(
    xValues = list(
      dimension = xDimension,
      unit = xUnit
    ),
    yValues = list(
      dimension = yDimension[1],
      unit = yUnit[1]
    )
  )
  if (length(yUnit) == 2) {
    metaData[["y2"]] <- list(
      dimension = yDimension[2],
      unit = yUnit[2]
    )
  }

  return(metaData)
}


#' creates mapping for plotData
#'
#' @param plotData to map
#' @param metaData list with metaData for plotData
#'
#' @return mapping
.getMappingForTimeprofiles <- function(plotData, metaData, userMapping) {
  #initialize variables used for data.table to avoid messages during checks
  xValues <- yValues <- group <-NULL

  mapping <- aes(x = xValues, y = yValues, groupby = group)

  # delete columns not needed
  plotData <- plotData[, which(colSums(is.na(plotData)) != nrow(plotData)), with = FALSE]

  if ("yErrorType" %in% names(plotData) &&
    any(plotData[["yErrorType"]] %in% unlist(ospsuite::DataErrorType))) {
    checkmate::assertNames(names(plotData),
      must.include = c("yErrorValues"),
      disjunct.from = c("yMin", "yMax"),
      .var.name = "columns needed for yErrorValues"
    )

    if (length(unique(plotData[!is.na(yErrorType)][["yErrorType"]])) > 1) {
      stop("Please do not mix different error Types in one plot")
    }

    if (any(plotData[["yErrorType"]] == ospsuite::DataErrorType$ArithmeticStdDev)) {
      mapping <- structure(c(mapping, aes(error = yErrorValues)), class = "uneval")
    }

    if (any(plotData[["yErrorType"]] == ospsuite::DataErrorType$GeometricStdDev)) {
      mapping <- structure(c(mapping, aes(error_relative = yErrorValues)), class = "uneval")
    }
  } else if (any(c("yMin", "yMax") %in% names(plotData))) {
    checkmate::assertNames(names(plotData), must.include = c("yMin", "yMax"))
    mapping <- structure(c(mapping, aes(ymin = yMin, ymax = yMax)), class = "uneval")
  }
  if (any(names(plotData) %in% "lloq")) {
    mapping <- structure(c(mapping, aes(lloq = lloq)), class = "uneval")
  }

  if (any(names(metaData) %in% "y2")) {
    mapping <- structure(
      c(
        mapping,
        eval(parse(
          text = paste0(
            "aes( y2axis = yUnit == '",
            metaData[["y2"]][["unit"]], "')"
          )
        ))
      ),
      class = "uneval"
    )
  }

  if (!is.null(userMapping)) {
    mapping <- structure(utils::modifyList(mapping, userMapping), class = "uneval")
  }


  return(mapping)
}
