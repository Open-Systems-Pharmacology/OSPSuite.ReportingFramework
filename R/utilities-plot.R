#' Run Plot Function
#'
#' This function generates .Rmd files for creating plots based on user-defined configurations.
#' It reads the specified configuration table, evaluates the selected plot function, and manages
#' the output of plots and tables.
#'
#' @param projectConfiguration A ProjectConfiguration object containing the project configuration settings.
#' This should include paths to input files and output directories.
#' @param nameOfplotFunction The name of the plot-function as character. The package provide a set of functions which can be addressed,
#'  but is also possible to generate a customized function ( see details). Available are
#'  - plotTimeProfiles
#'  - plotPKBoxwhisker
#'  - plotPKForestAggregatedAbsoluteValues
#'  - plotPKForestPointEstimateOfAbsoluteValues
#'  - plotPKForestAggregatedRatios
#'  - plotPKForestPointEstimateOfRatios
#'  for more details check the help of these functions
#' @param configTableSheet A character string representing the name of the sheet in the `Plots` configuration table
#'  from which to read plot configurations. It should have at least the columns `Header`,`Levels` and `PlotName`
#' @param rmdName A character string specifying the name of the resulting rmd and the sub-folder where results will be saved.
#'  The default value will be the sheet name of the plot configuration.
#' @param digitsOfSignificanceCSVDisplay digits Of significance used for the display in the .Rmd for tables, which are exported as .csv
#' @param suppressExport A logical value indicating whether to suppress the export of the Rmd file.
#'  If TRUE, the function will return the generated plots as a list without creating the Rmd file
#' @param plotNames A character vector of plot names to filter which plots should be generated. Default is NULL.
#' If provided, `suppressExport` is set to TRUE, all plots specified in the configuration will be processed and provided as list, but not exported to the Rmd file.
#' @param inputs A list of additional inputs for the plot function. This can include any parameters that the selected plot function requires.
#'
#' @return An invisible list of plots generated by the function. Each element in the list corresponds to a plot created during the execution. If `plotNames` is provided, the Rmd export is suppressed, and only the plot list is returned.
#'
#' @details
#' The `runPlot` function is designed to facilitate the generation of plots based on configurations defined in a specified configuration table. The function will:
#' - Load the configuration table for plots based on the specified sheet name.
#' - Validate the configuration and ensure that all required parameters are provided.
#' - Execute the designated plot function.
#' - Save the generated plots in the specified subfolder named  rmdName, if export is not suppressed.
#'
#' If the `plotNames` parameter is set, the function will suppress the Rmd export and return a list of plots generated instead.
#' This is useful when you want to generate specific plots without creating an accompanying .Rmd file for fast check in the daily work.
#'
#' Users can utilize the `openFigureTemplate` function to open a template for creating custom plot functions.
#' This function can be called directly: `openFigureTemplate().` Additionally, the template is available as an RStudio Add-in for easy access.
#'
#' @examples
#' \dontrun{
#' # Run the plot generation function with Rmd export
#' runPlot(
#'   projectConfiguration = projectConfiguration,
#'   nameOfplotFunction = "plotTimeProfiles",
#'   configTableSheet = "TimeProfiles",
#'   inputs = list(dataObserved = dataObserved, scenarioResults = scenarioResults)
#' )
#'
#' # Run the plot generation function without Rmd export, returning a plot list
#' plotList <- runPlot(
#'   projectConfiguration = projectConfiguration,
#'   nameOfplotFunction = "plotTimeProfiles",
#'   configTableSheet = "TimeProfiles",
#'   plotNames = c("Plot1", "Plot2"),
#'   inputs = list(dataObserved = dataObserved, scenarioResults = scenarioResults)
#' )
#'
#' # open the template for custom plot functions
#' openFigureTemplate()
#' }
#'
#' @export
runPlot <- function(projectConfiguration,
                    nameOfplotFunction,
                    configTableSheet = NULL,
                    rmdName = configTableSheet,
                    plotNames = NULL,
                    suppressExport = FALSE,
                    digitsOfSignificanceCSVDisplay = 3,
                    inputs = list()) {
  loadConfigTableEnvironment(projectConfiguration)

  suppressExport <- shouldSuppressExport(suppressExport, plotNames, inputs)

  rmdPlotManager <- initializePlotManager(
    projectConfiguration = projectConfiguration,
    rmdName = rmdName,
    nameOfplotFunction = nameOfplotFunction,
    digitsOfSignificanceCSVDisplay = digitsOfSignificanceCSVDisplay,
    suppressExport = suppressExport
  )

  configTable <- readConfigTableForPlot(
    projectConfiguration = projectConfiguration,
    sheetName = configTableSheet,
    validateConfigTableFunction = rmdPlotManager$validateConfigTableFunction,
    plotNames = plotNames,
    inputs = inputs
  )

  if (is.null(configTable)) {
    plotList <- handleNoConfigTable(
      rmdPlotManager = rmdPlotManager,
      projectConfiguration = projectConfiguration,
      inputs = inputs
    )
  } else {
    plotList <- handleConfigTable(
      rmdPlotManager = rmdPlotManager,
      configTable = configTable,
      projectConfiguration = projectConfiguration,
      inputs = inputs,
      suppressExport = suppressExport
    )
  }

  rmdPlotManager$writeRmd()
  return(invisible(plotList))
}
#' Determine if Export Should be Suppressed
#'
#' This helper function checks whether the export of the Rmd file should be suppressed based on user-defined conditions.
#'
#' @param suppressExport A logical value indicating the current state of export suppression.
#' @param plotNames A character vector of plot names to filter which plots should be generated. Default is NULL.
#' @param inputs A list of additional inputs that may contain parameters influencing the export behavior.
#'
#' @return A logical value indicating whether the export should be suppressed (TRUE) or not (FALSE).
#'
#' @keywords internal
shouldSuppressExport <- function(suppressExport, plotNames, inputs) {
  return(suppressExport || !is.null(plotNames) || (!is.null(inputs$checkForUnusedData) && inputs$checkForUnusedData))
}
#' Initialize the Plot Manager
#'
#' This helper function creates an instance of the RmdPlotManager for managing Rmd file generation and plot exports.
#'
#' @param projectConfiguration A ProjectConfiguration object containing the project configuration settings.
#' @param rmdName A character string specifying the name of the resulting Rmd and the subfolder where results will be saved.
#' @param nameOfplotFunction The name of the plot function as character, indicating which plotting function to use.
#' @param digitsOfSignificanceCSVDisplay digits Of significance used for the display in the .Rmd for tables, which are exported as .csv
#' @param suppressExport A logical value indicating whether to suppress the export of the Rmd file.
#'
#' @return An RmdPlotManager object initialized with the specified parameters.
#'
#' @details
#' The `initializePlotManager` function sets up the RmdPlotManager, which is responsible for generating the Rmd files
#' and managing the export of plots. It takes various parameters to configure the manager according to user needs.
#'
#' @keywords internal
initializePlotManager <- function(projectConfiguration, rmdName, nameOfplotFunction, digitsOfSignificanceCSVDisplay, suppressExport) {
  return(RmdPlotManager$new(
    rmdfolder = file.path(projectConfiguration$outputFolder),
    suppressExport = suppressExport,
    rmdName = rmdName,
    nameOfplotFunction = nameOfplotFunction,
    digitsOfSignificance = digitsOfSignificanceCSVDisplay
  ))
}
#' Handle Case with No Configuration Table
#'
#' This helper function processes the plotfunctions where no configuration table is provided,
#' generating plots based on default settings and exporting them.
#'
#' @param rmdPlotManager An RmdPlotManager object responsible for managing Rmd file generation and plot exports.
#' @param projectConfiguration A ProjectConfiguration object containing the project configuration settings.
#' @param inputs A list of additional inputs for the plot function.
#' @param suppressExport A logical value indicating whether to suppress the export of the Rmd file.
#'
#' @return NULL
#'
#' @keywords internal
handleNoConfigTable <- function(rmdPlotManager, projectConfiguration, inputs, suppressExport) {
  plotList <- do.call(
    what = rmdPlotManager$plotFunction,
    args = c(list(projectConfiguration = projectConfiguration, configTable = NULL), inputs)
  )
  if (!suppressExport) {
    rmdPlotManager$exportPlotList(plotList)
    return(list())
  }
  return(plotList)
}
#' Handle Configuration Table Processing
#'
#' This helper function processes the configuration table, generating plots according to the specified configurations.
#'
#' @param rmdPlotManager An RmdPlotManager object responsible for managing Rmd file generation and plot exports.
#' @param configTable A data frame containing the configuration settings for the plots.
#' @param projectConfiguration A ProjectConfiguration object containing the project configuration settings.
#' @param inputs A list of additional inputs for the plot function.
#' @param suppressExport A logical value indicating whether to suppress the export of the Rmd file.
#'
#' @return NULL
#'
#' @keywords internal
handleConfigTable <- function(rmdPlotManager, configTable, projectConfiguration, inputs, suppressExport) {
  plotList <- list()
  iRow <- 1
  levelLines <- which(!is.na(configTable$level))
  while (iRow <= nrow(configTable)) {
    if (!is.na(configTable$level[iRow])) {
      # Add section headers
      rmdPlotManager$addHeader(configTable$header[iRow], level = configTable$level[iRow])
      iRow <- iRow + 1
    } else {
      # Execute plot section
      iEndX <- utils::head(which(levelLines > iRow), 1)
      iEnd <- if (length(iEndX) == 0) nrow(configTable) else levelLines[iEndX] - 1

      for (onePlotConfig in split(configTable[seq(iRow, iEnd)], by = "plotName")) {
        tryCatch(
          {
            plotListiRow <- do.call(
              what = rmdPlotManager$plotFunction,
              args = c(
                list(
                  projectConfiguration = projectConfiguration,
                  onePlotConfig = onePlotConfig
                ),
                inputs
              )
            )
            if (suppressExport) {
              if ("unusedDataRows" %in% names(plotList) &&
                !is.null(plotListiRow[["unusedDataRows"]])) {
                plotList[["unusedDataRows"]] <-
                  rbind(plotList[["unusedDataRows"]],
                    plotListiRow[["unusedDataRows"]],
                    fill = TRUE
                  ) %>%
                  unique()
                plotListiRow[["unusedDataRows"]] <- NULL
              }
              plotList <- c(plotList, plotListiRow)
            } else {
              rmdPlotManager$exportPlotList(plotListiRow)
            }
          },
          error = function(err) {
            if (!getOption("OSPSuite.RF.skipFailingPlots", default = FALSE)) {
              stop(err)
            } else {
              warning(paste0("Error during creation of plot: '", onePlotConfig$plotName[1], "':\n ", conditionMessage(err)))
            }
          }
        )
      }
      iRow <- iEnd + 1
    }
  }
  return(plotList)
}
#' Read Configuration Table for Plot
#'
#' This function reads a configuration table from an Excel file, filters it based on specified plot names,
#' and merges scenario information. It also validates the resulting configuration table using a provided
#' validation function.
#'
#' @param projectConfiguration A ProjectConfiguration object
#' @param sheetName A character string specifying the name of the sheet to read from the Excel file.
#'                  If NULL, the function returns NULL.
#' @param validateConfigTableFunction A function that validates the configuration table.
#' @param inputs A list of additional inputs to be passed to the validation function.
#' @param plotNames A character vector of plot names to filter the configuration table. If NULL, no filtering is applied.
#'
#' @return A data.table containing the filtered and validated configuration table, or NULL if sheetName is NULL.
#'
#' @keywords internal
readConfigTableForPlot <- function(projectConfiguration,
                                   sheetName,
                                   validateConfigTableFunction,
                                   inputs,
                                   plotNames) {
  plotName <- scenarioName <- scenarioLongName <- NULL

  if (is.null(sheetName)) {
    return(NULL)
  }

  # read configuration tables
  configTable <- xlsxReadData(
    wb = projectConfiguration$plotsFile,
    sheetName = sheetName,
    skipDescriptionRow = TRUE
  )

  # filter rows with selected plotNames
  if ("plotName" %in% names(configTable) & !is.null(plotNames)) {
    checkmate::assertNames(plotNames, subset.of = configTable[!is.na(plotName)]$plotName)
    configTable <- configTable[plotName %in% plotNames]
  }
  # add scenario names
  if ("scenarios" %in% names(configTable)) {
    configTable <- separateAndTrim(data = configTable, columnName = "scenarios")
  }
  if ("scenario" %in% names(configTable)) {
    configTable <-
      merge(
        configTable,
        configEnv$scenarios[, c("scenarioName", "longName", "shortName")],
        by.x = "scenario",
        by.y = "scenarioName",
        all.x = TRUE,
        sort = FALSE
      ) %>%
      data.table::setnames(
        old = c("longName", "shortName"),
        c("scenarioLongName", "scenarioShortName")
      )

    if ("scenarioName" %in% names(configTable)) {
      configTable[
        !is.na(scenarioName) & scenarioName != "",
        scenarioLongName := scenarioName
      ]
    }
  }

  # validate
  do.call(
    what = validateConfigTableFunction,
    args = c(
      list(configTable = configTable),
      inputs
    )
  )


  return(configTable)
}

# auxiliaries ----
#' Add Facets to a ggplot Object
#'
#' This function adds facets to a given ggplot object, allowing for better visualization of data subsets.
#' Faceting is done by the variable `plotTag`.
#'
#' @param plotObject A ggplot object to which the facets should be added.
#' @param facetScale A character string indicating the scale of the facets. Options are "free", "fixed", "free_x", or "free_y".
#' @param facetAspectRatio A numeric value specifying the aspect ratio of the facets. Default is 0.5.
#' @param nFacetColumns An integer specifying the number of columns to use for the facet layout. If NULL, no faceting is done.
#'
#' @return An updated ggplot object with facets added.
#' @keywords internal
addFacets <- function(plotObject,
                      facetScale,
                      facetAspectRatio = 0.5,
                      nFacetColumns) {
  # avoid warnings for global variables during check
  plotTag <- NULL

  plotObject <- plotObject +
    ggplot2::theme(aspect.ratio = facetAspectRatio)


  if (!is.null(nFacetColumns)) {
    plotObject <- plotObject +
      ggplot2::facet_wrap(
        facets = ggplot2::vars(plotTag),
        scales = facetScale,
        ncol = nFacetColumns
      ) +
      ggplot2::theme(
        strip.background = ggplot2::element_rect(fill = NA, color = NA),
        strip.text = ggplot2::element_text(hjust = 0, vjust = 1)
      )
  }

  return(plotObject)
}


#' @title Set Export Attributes for Plot and Table Objects
#' @description
#' This function prepares plot and table objects by setting their export attributes,
#' such as caption and footnote lines, which will be used when exporting through
#' the `PlotManager` class.
#'
#' @param object An object (e.g., a plot or table) for which export attributes will be set.
#' @param caption A character string specifying the caption for the object. If NULL, no caption will be set.
#' @param footNoteLines A character vector specifying footnote lines for the object. If, no footnote lines will be set.
#' @param exportArguments A list of additional arguments such as width or height passed on to `ospsuite.plots::exportPlot`.
#'
#' @return The modified object with the specified export attributes set.
#' @export
setExportAttributes <- function(object,
                                caption = NULL,
                                footNoteLines = NULL,
                                exportArguments = NULL) {
  # Replace multiple spaces with a single space in the caption
  if (!is.null(caption)) {
    caption <- gsub(" +", " ", caption)
  }

  attributesToSet <- list(
    caption = caption,
    footNoteLines = footNoteLines,
    exportArguments = exportArguments
  )

  for (attrName in names(attributesToSet)) {
    if (!is.null(attributesToSet[[attrName]])) {
      setattr(object, attrName, attributesToSet[[attrName]])
    }
  }


  return(object)
}




#' Returns a Scale Vector Usable for Manual Scaling in ggplot
#'
#' @param namesOfScaleVector Names of the vector.
#' @param listOfValues List of possible entries. Takes the first where all values are not NA.
#'
#' @return A scale vector.
#' @keywords internal
getScalevector <- function(namesOfScaleVector,
                           listOfValues) {
  checkmate::assertCharacter(namesOfScaleVector, any.missing = FALSE, min.len = 1, unique = TRUE)
  checkmate::assertList(listOfValues)

  scaleVector <- NULL
  for (values in listOfValues) {
    if (!is.null(values) && !any(is.na(values))) {
      scaleVector <- values
      break
    }
  }

  if (is.null(scaleVector)) {
    stop(paste("no valid values for scalevector for", paste0(namesOfScaleVector, collapse = ", ")))
  }

  names(scaleVector) <- namesOfScaleVector

  return(scaleVector)
}


#' Get Default Colors for Scale Vector
#'
#' This function generates a vector of default colors based on the specified shade and number of colors required.
#' It provides colors from the ggsci package for small numbers and a custom color map for larger requests.
#'
#' @param shade A character string indicating the shade of colors to return.
#'   Must be either "dark" or "light". Default is "dark".
#'
#' @param n An integer specifying the number of colors to return. Must be greater than or equal to 1.
#'
#' @details
#' - For `n` values less than or equal to 10, the function uses the ggsci package's "category20c" palette.
#' - For `n` values greater than 10, it retrieves colors from the predefined color map of the package `ospsuite.plots` named "ospDefault".
#' - If `n` exceeds the maximum number of colors available in "ospDefault", an error is raised.
#'
#' @return A character vector of color values in hexadecimal format.
#'
#' @keywords internal
getDefaultColorsForScaleVector <- function(shade = c("dark", "light"), n) {
  checkmate::assertIntegerish(n, lower = 1, len = 1)
  shade <- match.arg(shade)
  if (n <= 10) {
    colorVector <-
      switch(shade,
        dark = ggsci::pal_d3("category20c")(20)[1:n], # nolint indentation_linter
        light = ggsci::pal_d3("category20c")(20)[(10 + 1):(10 + n)]
      )
  } else {
    if (n > length(ospsuite.plots::colorMaps[["ospDefault"]])) {
      stop(paste("To many colors for colorVector, maximal", length(ospsuite.plots::colorMaps[["ospDefault"]]), "allowed"))
    }
    colorVector <- ospsuite.plots::colorMaps[["ospDefault"]][1:n]
  }

  return(colorVector)
}


#' Get Default Shapes for Scale Vector
#'
#' This function retrieves a vector of default shapes for plotting based on the specified number of shapes required.
#' It utilizes shape settings from the ospsuite.plots package.
#'
#' @param n An integer specifying the number of shapes to return. Must be greater than or equal to 1.
#'
#' @details
#' - The function calls `getOspsuite.plots.option` to obtain the default shape values.
#' - If no shapes are available, an error is raised, prompting the user to set defaults using `ospsuite.plots::setDefaults()`.
#' - If the requested number of shapes exceeds the available shapes, an error is raised.
#'
#' @return A character vector of shape values.
#'
#' @keywords internal
getDefaultShapesForScaleVector <- function(n) {
  shapes <- ospsuite.plots::getOspsuite.plots.option(optionKey = ospsuite.plots::OptionKeys$shapeValues)
  if (is.null(shapes)) {
    stop("no default shape sets for ospsuite.plots. Please use ospsuite.plots::setDefaults()")
  }

  if (n > length(shapes)) {
    stop("not enough shapes available")
  }

  return(shapes[1:n])
}



#' generates named color vectors usable for scale_color_manual
#'
#' @param dt `data.table` with aesthetic and index column
#' @param aesthetic  named `list`, names correspond to aesthetic columns,
#'          entries are either 'dark' or 'light'
#' @param index name of index column
#'
#' @return named list of color vectors
#' @export
generateColorScaleVectors <- function(dt,
                                      aesthetic = list(
                                        color = "dark",
                                        fill = "light"
                                      ),
                                      index = "colorIndex") {
  n <- nrow(dt)
  scaleVectors <- list()
  for (col in names(aesthetic)) {
    for (col2 in c(col, setdiff(names(aesthetic), col))) {
      if (!all(is.na(scaleVectors[[col]]))) {
        scaleVectors[[col]] <- dt[[col2]]
        break
      }
    }

    if (is.null(scaleVectors[[col]])) {
      if (n <= 10) {
        if (aesthetic[[col]] == "dark") {
          scaleVectors[[col]] <- ggsci::pal_d3("category20c")(20)[1:n]
        } else {
          scaleVectors[[col]] <- ggsci::pal_d3("category20c")(20)[(10 + 1):(10 + n)]
        }
      } else {
        scaleVectors[[col]] <- ospsuite.plots::colorMaps[["ospDefault"]][1:n]
      }
    }
    names(scaleVectors[[col]]) <- dt[[index]]
  }
  return(scaleVectors)
}

#' Get Color Vector for Legend
#'
#' This function generates a color vector for a given color legend,
#' using a specified color vector to modify default colors. The
#' color legend is expected to be a character string containing
#' color names separated by a pipe (`|`). The function first validates
#' the provided color vector, then generates default colors, and
#' applies any colors from the specified color vector.
#'
#' @param colorLegend A character string containing color names
#'                    separated by a pipe (`|`).
#' @param colorVector A named character vector where names correspond
#'                    to color names in `colorLegend`. This vector
#'                    will be used to modify the default color values.
#'
#' @return A named character vector of colors corresponding to the
#'         provided color legend.
#' @keywords internal
getColorVectorForLegend <- function(colorLegend, colorVector) {
  checkmate::assertCharacter(colorLegend, any.missing = FALSE, len = 1)
  validateColorVector(colorVector)

  colorLegendList <- trimws(strsplit(as.character(colorLegend), "\\|")[[1]])

  # Generate default colors for the scale vector
  colorVectorNew <- getDefaultColorsForScaleVector(n = length(colorLegendList))
  names(colorVectorNew) <- colorLegendList

  # Modify the default colors with the provided color vector
  colorVectorNew <- unlist(utils::modifyList(as.list(colorVectorNew), as.list(colorVector[colorLegendList])))

  return(colorVectorNew)
}

#' Paste Figure Tags for Captions
#'
#' This function generates a formatted caption text by combining unique captions with associated plot tags.
#' If all captions are the same, it returns that caption. Otherwise, it creates a string that includes
#' the unique captions and their corresponding tags.
#'
#' @param dtCaption A data.table containing the captions and plot tags. It must have at least the following columns:
#'   - `captionColumn`: The column name containing the captions.
#'   - `plotTag`: A column containing the plot tags associated with each caption.
#' @param captionColumn A string specifying the name of the column in `dtCaption` that contains the captions.
#' @param endWithDot A logical value indicating whether to append a period at the end of the caption text. Default is FALSE.
#' @param startWithBlank boolean if TRUE adds as prefix a blank
#'
#' @return A character string representing the formatted caption text, which includes the captions and associated plot tags.
#'
#' @keywords internal
pasteFigureTags <- function(dtCaption, captionColumn, endWithDot = FALSE, startWithBlank = FALSE) {
  # avoid warning for global variable
  plotTag <- NULL

  if (dplyr::n_distinct(dtCaption[[captionColumn]]) == 1) {
    captionText <- as.character(unique(dtCaption[[captionColumn]]))
  } else {
    captionTextVector <- dtCaption[, .(tags = paste0(
      get(captionColumn),
      " (", paste(unique(plotTag), collapse = ", "), ")"
    )),
    by = captionColumn
    ]$tags

    allTags <- dtCaption[, .(tags = paste0(" \\(", paste(unique(plotTag), collapse = ", "), "\\)"))]$tags

    captionTextVector <- gsub(allTags, "", captionTextVector)

    captionText <- concatWithAnd(captionTextVector)
  }
  if (endWithDot && trimws(captionText) != "" && !grepl("\\.$", captionText)) {
    captionText <- paste0(captionText, ".")
  }
  if (startWithBlank & trimws(captionText) != "") {
    captionText <- paste0(" ", trimws(captionText))
  }

  return(captionText)
}

#' Add Text to caption text
#'
#' This function modifies a caption text by ensuring it ends with a period
#' and appending an additional caption if provided. Ensure the additional caption
#' ends also with a period before adding the additional text.
#'
#' @param captiontext A character string representing the main caption text.
#' @param plotCaptionAddon A character string representing the additional caption
#' text to be added. If NULL or NA, it will not be added.
#' @return A modified caption text with the additional caption added if applicable.
#' @keywords internal
addCaptionTextAddon <- function(captiontext, plotCaptionAddon) {
  captiontext <- trimws(captiontext)
  if (!grepl("\\.$", captiontext)) {
    captiontext <- paste0(captiontext, ".")
  }

  if (!is.na(plotCaptionAddon) && plotCaptionAddon != "") {
    if (!grepl("\\.$", plotCaptionAddon)) {
      plotCaptionAddon <- paste0(plotCaptionAddon, ".")
    }
    captiontext <- paste0(captiontext, " ", plotCaptionAddon)
  }

  return(captiontext)
}
#' Concatenate Text Vector with Commas and "and"
#'
#' This function takes a vector of text strings and concatenates them into a single string.
#' For vectors with more than two elements, it separates them with commas and uses "and"
#' before the last element.
#'
#' @param textVector A character vector of text strings to be concatenated.
#' @return A single character string representing the concatenated text.
#'
#' @keywords internal
concatWithAnd <- function(textVector) {
  textVector <- trimws(textVector)
  textVector <- textVector[textVector != ""]

  n <- length(textVector)

  if (n == 0) {
    return("")
  } else if (n == 1) {
    return(textVector)
  } else if (n == 2) {
    return(paste(textVector, collapse = " and "))
  } else {
    return(concatWithAnd(c(paste(textVector[1:(n - 1)], collapse = ", "), utils::tail(textVector, 1))))
  }
}


# " Process Percentiles
# "
#' This function takes a numeric vector of percentiles and maps specific values to their corresponding labels.
#' It also formats other numeric values based on whether they are integers or not.
#'
#' @param percentiles A numeric vector of percentiles (0, 50, 100, and other values).
#' @param suffix A character string to append to formatted percentile values.
#' @param allAsPercentiles boolean, if FALSE for percentiles = 0,50,100 min, median and max is returned
#'  otherwise 0th 50th 100th
#'
#' @return A vector containing the mapped labels for specific percentiles and formatted strings for others.
formatPercentiles <- function(percentiles, suffix = "", allAsPercentiles = FALSE) {
  lapply(percentiles * 100, function(p) {
    if (p == 0 & !allAsPercentiles) {
      "min"
    } else if (p == 50 & !allAsPercentiles) {
      "median"
    } else if (p == 100 & !allAsPercentiles) {
      "max"
    } else if (p %% 1 == 0) {
      paste0(scales::label_ordinal()(x = p), suffix)
    } else {
      paste0(p, "th", suffix)
    }
  }) %>% unlist()
}

#' Generate a Plot Tag
#'
#' This function generates a plot tag based on the provided index.
#' The function takes an index and returns the corresponding letter
#' from the alphabet in uppercase.
#'
#' @param index An integer representing the position in the alphabet
#'
#' @return A character string representing the uppercase letter
#' corresponding to the given index.
#' @keywords internal
generatePlotTag <- function(index) {
  toupper(letters[index])
}

#' Get Y-axis Limits for Plotting
#'
#' This function retrieves the y-axis limits from a given plot configuration
#' based on the specified y-axis scale (linear or logarithmic). It also allows
#' for additional arguments to be passed for further customization.
#'
#' @param onePlotConfig A list containing the plot configuration, which must
#' include `ylimit_linear` and `ylimit_log` elements if direction is `y` otherwise
#' `xlimit_linear` and `xlimit_log`
#'
#' @param xOryScale A character string indicating the type of scale to use for the
#' y(x)-axis. It should be either "linear" or "log".
#'
#' @param direction A character string indicating direction of the axis must be `x` or `y`
#' default is `y`.
#'
#' @param ... Additional arguments that can be passed to customize the y-scale.
#' These can include `yscale.args` for further customization of the y-axis scale.
#'
#' @return A list of y-scale arguments, including limits, which can be used
#' in plotting functions.
#' @keywords internal
getXorYlimits <- function(onePlotConfig, xOryScale, direction = c("y", "x"), ...) {
  direction <- match.arg(direction)

  dotargs <- list(...)
  if (paste0(direction, "scale.args") %in% dotargs) {
    xOrYscaleArgs <- dotargs[[paste0(direction, "scale.args")]]
  } else {
    xOrYscaleArgs <- list()
  }

  # Construct the column name
  columnName <- paste0(direction, "limit_", tolower(xOryScale))
  if (!(columnName %in% names(onePlotConfig))) {
    columnName <- paste0("limit_", tolower(xOryScale))
  }
  scaleTxt <- onePlotConfig[[columnName]][1]

  if (!is.null(scaleTxt) && !is.na(scaleTxt)) {
    xOrYscaleArgs <- utils::modifyList(
      xOrYscaleArgs,
      list(limits = eval(parse(text = scaleTxt)))
    )
  }

  return(xOrYscaleArgs)
}



# validation ----------------
#' Validate Configuration Table for Plots
#'
#' This function validates the structure and content of the configuration table for plots.
#'
#' @param configTable A data.table containing the plot configuration to be validated.
#' @return NULL. The function will throw an error if the validation fails.
#' @keywords internal
validateConfigTableForPlots <- function(configTable, ...) {
  invisible(validateHeaders(configTable))
  validateOutputIdsForPlot()
  validateDataGroupIdsForPlot()

  return()
}

#' checks if config table header and plot rows are strict separated
#'
#' @param configTable `data.table` configuration table to check
#'
#' @return configuration table without header lines
#' @export
validateHeaders <- function(configTable) {
  # avoid warning for global variable
  level <- NULL

  configTableHeader <- configTable[!is.na(level)]
  checkmate::assertIntegerish(configTableHeader$level, lower = 1, any.missing = FALSE)
  checkmate::assertCharacter(configTableHeader$header, any.missing = FALSE)

  if (any(!is.na(configTableHeader %>% dplyr::select(setdiff(
    names(configTableHeader), c("level", "header")
  ))))) {
    stop(
      "Invalid plot configuration table. For Rows with headers all other columns must be empty."
    )
  }

  configTablePlots <- configTable[is.na(level)]
  if (!all(configTablePlots[,
    lapply(.SD, function(x) {
      all(is.na(x))
    }), # nolint indentation_linter
    .SDcols = "header"
  ])) {
    stop("Invalid plot configuration table. Missing header for level")
  }

  return(configTablePlots)
}

#' validate types of plot configuration tables
#'
#' @param configTablePlots `data.table` configuration table without header lines
#' @param charactersWithoutMissing vector with character columns, where no missing value is allowed
#' @param charactersWithMissing  vector with character column, where values may missing
#' @param numericColumns  vector with numeric columns
#' @param logicalColumns vector with booleans
#' @param numericRangeColumns vector with columns where entries must be evaluate to a numeric of length 2
#' @param subsetList  list where each entry is a list:
#'  list(cols = 'vector with columns',
#'  allowedValues = vector with allowed values)
#'
validateConfigTablePlots <- function(configTablePlots,
                                     charactersWithoutMissing = NULL,
                                     charactersWithMissing = NULL,
                                     numericColumns = NULL,
                                     logicalColumns = NULL,
                                     numericRangeColumns = NULL,
                                     subsetList = list()) {
  # Validate character columns
  if (!is.null(charactersWithoutMissing)) {
    invisible(lapply(charactersWithoutMissing, function(col) validateColumn(col, configTablePlots, "character", FALSE)))
  }

  if (!is.null(charactersWithMissing)) {
    invisible(lapply(charactersWithMissing, function(col) validateColumn(col, configTablePlots, "character", TRUE)))
  }

  # Validate numeric columns
  if (!is.null(numericColumns)) {
    invisible(lapply(numericColumns, function(col) validateColumn(col, configTablePlots, "numeric")))
  }

  # Validate logical columns
  if (!is.null(logicalColumns)) {
    invisible(lapply(logicalColumns, function(col) validateColumn(col, configTablePlots, "logical")))
  }

  # Validate subset list
  checkmate::assertList(subsetList, types = "list")
  validateSubsetList(subsetList, configTablePlots)

  if (!is.null(numericRangeColumns)) {
    validateNumericVectorColumns(numericRangeColumns, configTablePlots, len = 2)
  }

  return(invisible())
}

#' validate a Column
#'
#' This function validates a specified column in a data frame based on the
#' provided type. It checks for character, numeric, or logical types and
#' can enforce the presence or absence of missing values.
#'
#' @param col A string representing the name of the column to validate.
#' @param data A data frame containing the column to be validated.
#' @param type A string specifying the type of validation to perform.
#'             Options are "character", "numeric", or "logical".
#' @param anyMissing A logical value indicating whether missing values are allowed.
#'                   Default is FALSE.
#'
#' @return NULL. The function will throw an error if the validation fails.
#' @keywords internal
validateColumn <- function(col, data, type, anyMissing = FALSE) {
  switch(type,
    character = checkmate::assertCharacter(
      data[[col]],
      any.missing = anyMissing,
      .var.name = paste("Plot configuration column", col)
    ),
    numeric = checkmate::assertNumeric(data[[col]], .var.name = paste("Plot configuration column", col)),
    logical = checkmate::assertLogical(
      as.logical(data[[col]]),
      any.missing = FALSE,
      .var.name = paste("Plot configuration column", col)
    )
  )
}
#' validate Subset List
#'
#' Validates the subset list against the provided data frame.
#'
#' @param subsetList A list containing subsets to validate.
#' @param data A data frame containing the columns to validate.
validateSubsetList <- function(subsetList, data) {
  for (subsetCheck in subsetList) {
    invisible(lapply(subsetCheck$cols, function(col) {
      if (any(!is.na(data[[col]]))) {
        if (is.null(subsetCheck$allowedValues)) {
          stop(paste("Plot configuration column", col, "has entries but no allowed values.
                     Did you forget some inputs e.g. observedData or pkParameterDT?"))
        }
        splitAllowed <- subsetCheck$splitAllowed
        if (is.null(subsetCheck$splitAllowed)) splitAllowed <- TRUE
        if (splitAllowed) {
          x <- gsub("[()]", "", splitInputs(data[!is.na(get(col))][[col]]))
        } else {
          x <- data[!is.na(get(col))][[col]]
        }
        checkmate::assertNames(
          x,
          subset.of = as.character(subsetCheck$allowedValues),
          .var.name = paste("Plot configuration column", col)
        )
      }
    }))
  }
}


#' validate Numeric Range Columns
#'
#' Validates numeric range columns in the provided data frame.
#'
#' @param columns A vector of column names to validate.
#' @param data A data frame containing the columns to validate.
#' @param ... additionally parameters parsed to checkmate::assertNumeric
validateNumericVectorColumns <- function(columns, data, ...) {
  for (col in columns) {
    if (any(!is.na(data[[col]]))) {
      xList <- data[!is.na(get(col)), ][[col]]
      for (xcharacter in xList) {
        tryCatch(
          {
            x <- eval(parse(text = xcharacter))
          },
          error = function(e) {
            stop(paste("Invalid inputs in plot configuration column", col))
          }
        )
      }
      checkmate::assertNumeric(x = x, .var.name = paste("Plot configuration column", col), ...)
      # do.call(what = checkmate::assertNumeric,
      #         args = c(list(x = x,.var.name = paste("Plot configuration column", col)),
      #                  list(...))
      # )
    }
  }
}
#' Validate Consistency of Values Within Groups
#'
#' This function checks whether specified columns in a data table have consistent values
#' within groups defined by one or more grouping columns. If any column contains more than
#' one unique value within a group, an error is raised.
#'
#' @param dt A data.table or data.frame containing the data to be validated.
#' @param valueColumns A character vector of column names to check for consistency.
#' @param groupingColumns A character vector of column names that define the groups.
#'        Default is 'plotName'.
#'
#' @return Returns NULL (invisible) if all checks pass. Raises an error if any value
#'         column contains inconsistent values within a group.
#'
#' @export
validateGroupConsistency <- function(
    dt,
    valueColumns,
    groupingColumns = "plotName") {
  # Check for unique values of value columns for each group defined by groupingColumns
  uniqueValueCounts <-
    dt[, lapply(.SD, function(x) {
      length(unique(x))
    }),
    by = groupingColumns,
    .SDcols = valueColumns
    ]

  # Check if any value column has more than one unique value within each group
  lapply(valueColumns, function(col) {
    if (any(uniqueValueCounts[[col]] > 1)) {
      stop(paste("Values for", col, "should be the same within each group defined by", paste(groupingColumns, collapse = ", ")))
    }
  })

  return(invisible())
}


#' check if at least one of the following columns is selected
#'
#' @param configTablePlots `data.table` Configuration table without header lines
#' @param columnVector vector of columns to check
#'
validateAtleastOneEntry <- function(configTablePlots, columnVector) {
  if (nrow(configTablePlots[rowSums(is.na(configTablePlots)) == length(columnVector), ]) > 0) {
    stop(paste(
      "Invalid configTable, each plot row needs at least one entry in one of the columns",
      paste(columnVector, collapse = ", ")
    ))
  }

  return(invisible())
}


#' Validation of data.table with outputPath Ids
#'
#' @keywords internal
validateOutputIdsForPlot <- function() {
  # avoid warning for global variable
  outputPathId <- NULL

  checkmate::assertFactor(configEnv$outputPaths$outputPathId,
    any.missing = FALSE,
    .var.name = "Outputs column outputPathId"
  )
  checkmate::assertCharacter(configEnv$outputPaths$outputPath,
    any.missing = FALSE,
    .var.name = "Outputs column outputPath"
  )
  checkmate::assertCharacter(configEnv$outputPaths$displayNameOutput,
    any.missing = FALSE,
    .var.name = "Outputs column displayName"
  )

  if (any(!is.na(configEnv$outputPaths$color))) {
    checkmate::assertCharacter(configEnv$outputPaths$color,
      any.missing = FALSE,
      .var.name = "Outputs column color"
    )
  }

  # Check for unique values for outputpathids
  uniqueColumns <- c("displayNameOutput", "displayUnit")
  uniqueIDValues <-
    configEnv$outputPaths[, lapply(.SD, function(x) {
      length(unique(x))
    }), by = outputPathId, .SDcols = uniqueColumns]
  tmp <- lapply(uniqueColumns, function(col) { # nolint object_usage
    if (any(uniqueIDValues[[col]] > 1)) stop(paste("values for", col, "should be the same within outputPathId"))
  })

  # check validity of units
  invisible(lapply(
    unique(configEnv$outputPaths$displayUnit),
    function(unit) {
      tryCatch(
        {
          suppressMessages(ospsuite::getDimensionForUnit(unit))
        },
        error = function(e) {
          stop(paste0('Please check sheet Outputs in plotconfiguration file. Unit "', unit, '" is not valid'))
        }
      )
    }
  ))

  return(invisible())
}

#' Validation of data.table with outputPath Ids
#' @keywords internal
validateDataGroupIdsForPlot <- function() {
  # avoid warning for global variable
  dtOutputPaths <- NULL

  checkmate::assertFactor(
    configEnv$dataGroupIds$group,
    any.missing = FALSE,
    unique = TRUE,
    .var.name = "DataGroups column group"
  )
  checkmate::assertCharacter(configEnv$dataGroupIds$displayNameData,
    any.missing = FALSE,
    .var.name = "DataGroups column displayName"
  )

  if (any(!is.na(configEnv$dataGroupIds$color))) {
    checkmate::assertCharacter(dtOutputPaths$color,
      any.missing = FALSE,
      .var.name = "DataGroups column color"
    )
  }

  return(invisible())
}
" Validate Color Legend
#"
#' This function checks if the `colorLegend` column in a data.table contains
#' valid entries. Each entry must be a character string concatenated from
#' two characters separated by a pipe (`|`). If any entry does not meet this
#' requirement, the function will print the invalid entries and stop execution.
#'
#' @param dt A data.table containing a column named `colorLegend` and
#'            optionally a `plotName` column.
#'
#' @return NULL The function stops execution if invalid entries are found.
#'
#' @keywords internal
validateColorLegend <- function(dt) {
  # initialize variable to avoid messages
  colorLegend <- NULL

  dt <- dt[!grep("\\|", colorLegend)]

  if (nrow(dt) > 0) {
    print(dt[, c("plotName", "colorLegend")] %>%
      unique())
    stop("colorLegend must be a character string concatenated from two characters separated by |.")
  }

  return(invisible())
}
#' Validate Color Vector
#'
#' This function checks if the provided color vector meets the following criteria:
#' - It is named.
#' - All values are valid color names.
#'
#' @param colorVector A character vector of colors, which should have a length of 2.
#'
#' @return Returns `invisible()` if the checks pass.
#'
#' @keywords internal
validateColorVector <- function(colorVector) {
  # Check if vector is named
  checkmate::assertVector(colorVector, names = "named")

  # Check if all values are either NA or valid colors
  validColors <- sapply(colorVector, function(x) is.na(x) || isTRUE(grDevices::col2rgb(x, alpha = TRUE)[1] >= 0))

  if (!all(validColors)) {
    stop("All values in colorVector must be valid color names.")
  }

  return(invisible())
}
